<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stark Tech // Holographic Design Interface</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #video-input { display: none; transform: scaleX(-1); }
        
        /* JARVIS UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 100px rgba(0, 255, 255, 0.1);
        }
        .hud-text {
            position: absolute; color: #00ffff; text-shadow: 0 0 5px #00ffff;
            font-size: 14px; text-transform: uppercase; letter-spacing: 2px;
        }
        #top-left { top: 20px; left: 20px; border-left: 2px solid #00ffff; padding-left: 10px; }
        #bottom-right { bottom: 20px; right: 20px; text-align: right; border-right: 2px solid #00ffff; padding-right: 10px; }
        #scan-line {
            position: absolute; top: 50%; left: 0; width: 100%; height: 2px;
            background: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 10px #00ffff;
            animation: scan 4s infinite linear;
        }
        @keyframes scan {
            0% { top: 10%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 90%; opacity: 0; }
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">INITIALIZING SYSTEM...<br>ACCESSIBILITY SERVICES REQUIRED</div>

<div id="ui-layer">
    <div id="scan-line"></div>
    <div id="top-left" class="hud-text">
        PROJECT: ARC REACTOR MK-I<br>
        STATUS: UNSTABLE<br>
        <span style="font-size:10px; opacity:0.7">GESTURE CONTROL: ACTIVE</span>
    </div>
    <div id="bottom-right" class="hud-text">
        FRAMEWORK: THREE.JS<br>
        SYSTEM: ONLINE<br>
        <span id="gesture-state" style="color: yellow;">WAITING FOR INPUT...</span>
    </div>
</div>

<video id="video-input"></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- VARIABLES ---
    let scene, camera, renderer, composer;
    let gadgetGroup = new THREE.Group();
    let parts = []; // Store parts for "Exploded View"
    
    // Hand Tracking Data
    let handData = { x: 0.5, y: 0.5, pinch: 0, active: false };

    // --- SETUP SCENE ---
    function init() {
        // 1. Scene & Camera
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;

        // 2. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // 3. Post-Processing (THE GLOW)
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.0, 0.4, 0.1 // Strength, Radius, Threshold
        );
        
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. Create the "Arc Reactor" Gadget
        createGadget();

        // 5. Lighting
        const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        scene.add(new THREE.AmbientLight(0x404040));

        // 6. Listeners
        window.addEventListener('resize', onWindowResize);
        animate();
        document.getElementById('loading').style.display = 'none';
    }

    // --- PROCEDURAL GADGET GENERATOR ---
    function createGadget() {
        // We create a complex object made of multiple rings and cores
        // This represents a "Blueprint" being designed
        
        const materialWire = new THREE.MeshBasicMaterial({ 
            color: 0x00aaff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.3 
        });
        
        const materialSolid = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending 
        });

        // Part 1: Outer Ring (The Casing)
        const outerGeo = new THREE.TorusGeometry(4, 0.2, 16, 100);
        const outerRing = new THREE.Mesh(outerGeo, materialSolid);
        addToGadget(outerRing, 0, 0, 0, 'casing');

        // Part 2: Inner Coils (The Power Source)
        const coilGeo = new THREE.TorusGeometry(3, 0.5, 16, 50);
        const coils = new THREE.Mesh(coilGeo, materialWire);
        addToGadget(coils, 0, 0, 0, 'core');

        // Part 3: The Center Core (Energy Point)
        const coreGeo = new THREE.IcosahedronGeometry(1.5, 1);
        const center = new THREE.Mesh(coreGeo, materialSolid);
        addToGadget(center, 0, 0, 0, 'energy');

        // Part 4: Floating Connectors (Detailing)
        for(let i=0; i<8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const pegGeo = new THREE.CylinderGeometry(0.2, 0.2, 2);
            const peg = new THREE.Mesh(pegGeo, materialWire);
            
            peg.position.x = Math.cos(angle) * 3.5;
            peg.position.y = Math.sin(angle) * 3.5;
            peg.rotation.z = angle + Math.PI / 2;
            
            addToGadget(peg, peg.position.x, peg.position.y, peg.position.z, 'connector');
        }

        scene.add(gadgetGroup);
    }

    function addToGadget(mesh, x, y, z, type) {
        // We store the "Home" position so we can return to it after exploding
        mesh.userData = { 
            home: new THREE.Vector3(x, y, z),
            type: type,
            // Random explosion direction based on position
            explodeDir: new THREE.Vector3(x, y, z).normalize() 
        };
        // If center object, explode Z
        if(x===0 && y===0) mesh.userData.explodeDir = new THREE.Vector3(0,0,1);

        gadgetGroup.add(mesh);
        parts.push(mesh);
    }

    // --- ANIMATION & LOGIC ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. Rotation Logic (Hand controls rotation)
        if (handData.active) {
            // Smoothly rotate object based on hand position
            const targetRotX = (handData.y - 0.5) * 3;
            const targetRotY = (handData.x - 0.5) * 3;
            
            gadgetGroup.rotation.x += (targetRotX - gadgetGroup.rotation.x) * 0.1;
            gadgetGroup.rotation.y += (targetRotY - gadgetGroup.rotation.y) * 0.1;
        } else {
            // Idle Spin
            gadgetGroup.rotation.y += 0.005;
        }

        // 2. Exploded View Logic (Pinch controls expansion)
        // If pinch is SMALL (fingers touching), we are grabbing. 
        // If pinch is LARGE (open hand), we are releasing.
        // Let's reverse for "Magic": Pinch to Compress, Open to Explode? 
        // Better: Pinch to Pull Apart (Distance mapping)
        
        let explosionFactor = 0;
        
        if (handData.active) {
            // handData.pinch is roughly 0 (touching) to 0.5 (wide open)
            // Let's make "Wide Open Hand" = Exploded View
            if (handData.pinch > 0.2) {
                explosionFactor = (handData.pinch - 0.2) * 20; // Scale up
                document.getElementById('gesture-state').innerText = "MODE: EXPLODED VIEW";
            } else {
                 document.getElementById('gesture-state').innerText = "MODE: ASSEMBLED";
            }
        }

        // Apply Explosion positions
        parts.forEach(part => {
            const home = part.userData.home;
            const dir = part.userData.explodeDir;
            
            // Calculate target position
            const target = home.clone().add(dir.clone().multiplyScalar(explosionFactor));
            
            part.position.lerp(target, 0.1);
            
            // Also rotate parts slightly when exploded for cool effect
            part.rotation.z += explosionFactor * 0.001;
        });

        // 3. Render
        composer.render();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- COMPUTER VISION (MediaPipe) ---
    const videoElement = document.getElementById('video-input');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handData.active = true;
            const lm = results.multiHandLandmarks[0];

            // Position (Index Finger Knuckle)
            handData.x = 1 - lm[5].x; // Mirror
            handData.y = 1 - lm[5].y;

            // Pinch/Spread Calculation (Thumb tip to Index tip)
            const thumb = lm[4];
            const index = lm[8];
            const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
            handData.pinch = dist;

        } else {
            handData.active = false;
            handData.pinch = 0;
            document.getElementById('gesture-state').innerText = "WAITING FOR INPUT...";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });

    // Start
    cameraUtils.start().then(() => init());

</script>
</body>
</html>
