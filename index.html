<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; border-radius: 8px; transform: scaleX(-1); opacity: 0.7; }
        #ui { position: absolute; top: 20px; right: 20px; color: #00ffcc; text-align: right; z-index: 2; pointer-events: none; }
        .instruction { font-size: 14px; margin-bottom: 5px; color: rgba(255,255,255,0.7); }
        .active-mode { color: #fff; font-weight: bold; text-shadow: 0 0 10px #00ffcc; }
    </style>
</head>
<body>

    <video id="video-input" playsinline></video>

    <div id="canvas-container"></div>

    <div id="ui">
        <h2>Hand Particle Controller</h2>
        <div id="status">Initializing AI...</div>
        <hr style="border-color: #333">
        <div class="instruction">‚úã Open Palm: <b>Free Float</b></div>
        <div class="instruction">‚úåÔ∏è Victory Sign: <b>Heart Shape</b></div>
        <div class="instruction">ü§ü 3 Fingers: <b>Flower Shape</b></div>
        <div class="instruction">üëç Thumbs Up: <b>Saturn</b></div>
        <div class="instruction">üëå Pinch: <b>Collapse/Gravity</b></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 4000;
        const PARTICLE_SIZE = 0.15;
        const CAM_Z = 25;

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, particles, geometry, material;
        let positions = [], targets = [], colors = [];
        let currentShape = 'cloud'; 
        let isPinching = false;
        let handPosition = new THREE.Vector3(0, 0, 0);
        
        // --- THREE.JS SETUP ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = CAM_Z;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Create Particle System
            geometry = new THREE.BufferGeometry();
            
            // Initialize arrays
            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colorArray = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Initial positions (random cloud)
                positions.push(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                
                // Initial Targets (same as pos)
                targets.push({ x: positions[i*3], y: positions[i*3+1], z: positions[i*3+2] });

                // Colors (Blue-ish start)
                colors.push(0.2, 0.6, 1.0);
                
                posArray[i*3] = positions[i*3];
                posArray[i*3+1] = positions[i*3+1];
                posArray[i*3+2] = positions[i*3+2];
                
                colorArray[i*3] = 0.2;
                colorArray[i*3+1] = 0.6;
                colorArray[i*3+2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            // Shader Material for nice glowing dots
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- SHAPE GENERATORS ---
        // Returns an array of vector3 objects
        function getShapePositions(type) {
            const arr = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                
                if (type === 'heart') {
                    // Parametric Heart
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random(); // Fill inside
                    // Heart formula
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random() - 0.5) * 4; // Thickness
                    
                    // Scale down
                    x *= 0.5; y *= 0.5;
                    
                } else if (type === 'flower') {
                    // Rose/Flower curve
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 5 + 3 * Math.cos(4 * theta); // 4 petals
                    
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = (r * Math.cos(phi)) * 0.2; // Flatten slightly

                } else if (type === 'saturn') {
                    // Planet + Rings
                    const isRing = Math.random() > 0.4;
                    if (isRing) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 8 + Math.random() * 4; // Ring radius
                        x = Math.cos(angle) * radius;
                        z = Math.sin(angle) * radius;
                        y = (Math.random() - 0.5) * 0.5; // Thin ring
                    } else {
                        // Planet body
                        const u = Math.random();
                        const v = Math.random();
                        const theta = 2 * Math.PI * u;
                        const phi = Math.acos(2 * v - 1);
                        const radius = 4;
                        x = radius * Math.sin(phi) * Math.cos(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(phi);
                    }
                    // Tilt Saturn
                    const tilt = Math.PI / 6;
                    const tempX = x;
                    x = x * Math.cos(tilt) - y * Math.sin(tilt);
                    y = tempX * Math.sin(tilt) + y * Math.cos(tilt);

                } else { 
                    // Cloud / Random
                    const u = Math.random();
                    const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 10 * Math.cbrt(Math.random()); // Uniform sphere
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                arr.push({ x, y, z });
            }
            return arr;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsAttribute = geometry.attributes.position;
            const colorsAttribute = geometry.attributes.color;

            // Physics constants
            const lerpSpeed = 0.05;
            const pinchStrength = isPinching ? 0.5 : 0.01; // Attraction force to hand center

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let px = positionsAttribute.getX(i);
                let py = positionsAttribute.getY(i);
                let pz = positionsAttribute.getZ(i);

                let tx = targets[i].x;
                let ty = targets[i].y;
                let tz = targets[i].z;

                // 1. Move towards target shape (Local coordinates)
                px += (tx - px) * lerpSpeed;
                py += (ty - py) * lerpSpeed;
                pz += (tz - pz) * lerpSpeed;

                // 2. Apply Hand Interaction (Global Offset)
                // If pinching, suck particles into the hand position
                if (isPinching) {
                    // Calculate vector to hand
                    const dx = handPosition.x - px;
                    const dy = handPosition.y - py;
                    const dz = handPosition.z - pz;
                    
                    px += dx * 0.1; // Suction speed
                    py += dy * 0.1;
                    pz += dz * 0.1;

                    // Color shift to Red/Orange on pinch
                    colorsAttribute.setXYZ(i, 1.0, 0.2, 0.1); 
                } else {
                    // Just drift with hand position generally
                    // We add the hand position offset to the shape center
                    // To do this smoothly, we treat targets as relative to (0,0,0) 
                    // and just add hand pos during render logic or shift targets.
                    // Here, let's shift the WHOLE particle system target
                    
                    // Actually, simpler: Move the whole Group/Mesh
                    // We handle this outside the loop for performance, 
                    // BUT for the "Expansion" effect, we modify positions directly.
                    
                    // Reset color to Blue/Cyan
                    colorsAttribute.setXYZ(i, 0.2, (px/10)+0.5, 1.0);
                }

                // Add some noise/jitter for "life"
                px += (Math.random() - 0.5) * 0.05;
                py += (Math.random() - 0.5) * 0.05;
                pz += (Math.random() - 0.5) * 0.05;

                positionsAttribute.setXYZ(i, px, py, pz);
            }

            positionsAttribute.needsUpdate = true;
            colorsAttribute.needsUpdate = true;
            
            // Move entire particle cloud based on hand
            // Smooth damping
            particles.position.x += (handPosition.x - particles.position.x) * 0.1;
            particles.position.y += (handPosition.y - particles.position.y) * 0.1;

            // Rotate slowly
            particles.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        // --- MEDIAPIPE LOGIC ---
        function updateShape(type) {
            if (currentShape === type) return;
            currentShape = type;
            document.getElementById('status').innerHTML = `Mode: <span class="active-mode">${type.toUpperCase()}</span>`;
            
            // Recalculate targets
            const newTargets = getShapePositions(type);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                targets[i] = newTargets[i];
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Calculate Hand Position (Index finger base - approx center)
                // Map coordinates: MediaPipe is 0-1 (top-left origin). ThreeJS is -x to +x (center origin)
                // We invert X because webcam is mirrored
                const x = (0.5 - landmarks[9].x) * 30; // Scale to world units
                const y = (0.5 - landmarks[9].y) * 20;
                handPosition.set(x, y, 0);

                // 2. Detect Pinch (Thumb Tip vs Index Tip)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                isPinching = distance < 0.05;

                // 3. Detect Gestures
                // Check if fingers are extended (Tip higher than PIP joint - y is inverted in screen space)
                const indexUp = landmarks[8].y < landmarks[6].y;
                const middleUp = landmarks[12].y < landmarks[10].y;
                const ringUp = landmarks[16].y < landmarks[14].y;
                const pinkyUp = landmarks[20].y < landmarks[18].y;
                const thumbUp = landmarks[4].y < landmarks[3].y;

                if (isPinching) {
                    // Pinch overrides shapes
                    document.getElementById('status').innerText = "Gravity Well Active";
                } else if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) {
                    updateShape('saturn');
                } else if (indexUp && middleUp && ringUp && !pinkyUp) {
                    updateShape('flower');
                } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                    updateShape('heart');
                } else if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                    // Fist (optional, but using Open Palm for cloud)
                } else {
                    updateShape('cloud');
                }
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const videoElement = document.getElementById('video-input');
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // Start everything
        initThree();
        cameraUtils.start().then(() => {
            document.getElementById('status').innerText = "System Ready. Show Hand.";
        });

    </script>
</body>
</html>
