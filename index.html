<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand-Controlled 3D Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; }
        #video-input { display: none; transform: scaleX(-1); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; pointer-events: none; text-align: center;
        }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="loading">Initializing Camera & AI...<br>Please allow camera access.</div>
<div id="ui">
    <h3>Interactive Particle System</h3>
    <p>Current Shape: <span id="shape-name">Sphere</span></p>
    <p>üñê Move hand to rotate & color</p>
    <p>üëå Pinch to expand/explode</p>
</div>

<!-- Video element for MediaPipe (Hidden) -->
<video id="video-input"></video>

<!-- Dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const SHAPE_SWITCH_INTERVAL = 5000; // ms

    // --- VARIABLES ---
    let scene, camera, renderer, points;
    let particlesData = [];
    let currentShape = 'sphere';
    let time = 0;
    let handInteraction = {
        active: false,
        x: 0, y: 0, 
        pinchDistance: 0
    };

    // --- THREE.JS SETUP ---
    function initThree() {
        const container = document.body;
        
        // Scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Particles
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);

        // Initialize particles with random data
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            particlesData.push({
                velocity: new THREE.Vector3(),
                target: new THREE.Vector3(),
                initialPos: new THREE.Vector3()
            });
            sizes[i] = Math.random() * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Create a soft glow texture
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        const material = new THREE.PointsMaterial({
            size: 0.5,
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.8
        });

        points = new THREE.Points(geometry, material);
        scene.add(points);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Handle Window Resize
        window.addEventListener('resize', onWindowResize, false);
        
        // Start Loop
        animate();
        
        // Start Shape Cycle
        setInterval(cycleShapes, SHAPE_SWITCH_INTERVAL);
        calculateTargets('sphere'); // Initial shape
        document.getElementById('loading').style.display = 'none';
    }

    // --- MATH & SHAPES ---
    
    function getPointOnSphere(i) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 10;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    function getPointOnHeart(i) {
        // Parametric Heart
        const t = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        // 3D Heart variation
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        const z = 4 * Math.cos(phi) * Math.sin(t); // Give it thickness
        const scale = 0.5;
        return { x: x * scale, y: y * scale, z: z * scale };
    }

    function getPointOnFlower(i) {
        const u = Math.random() * Math.PI * 2;
        const v = Math.random() * Math.PI;
        const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v);
        return {
            x: r * Math.sin(v) * Math.cos(u),
            y: r * Math.sin(v) * Math.sin(u),
            z: r * Math.cos(v)
        };
    }

    function getPointOnSaturn(i) {
        // Mix of Sphere (Planet) and Ring
        if (i % 3 === 0) {
            // Ring
            const theta = Math.random() * Math.PI * 2;
            const r = 12 + Math.random() * 5;
            return { x: r * Math.cos(theta), y: Math.random(), z: r * Math.sin(theta) };
        } else {
            // Planet
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 6;
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }
    }

    function calculateTargets(shapeType) {
        currentShape = shapeType;
        document.getElementById('shape-name').innerText = shapeType.toUpperCase();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let pos;
            switch(shapeType) {
                case 'heart': pos = getPointOnHeart(i); break;
                case 'flower': pos = getPointOnFlower(i); break;
                case 'saturn': pos = getPointOnSaturn(i); break;
                case 'sphere': default: pos = getPointOnSphere(i); break;
            }
            particlesData[i].target.set(pos.x, pos.y, pos.z);
        }
    }

    function cycleShapes() {
        const shapes = ['sphere', 'heart', 'flower', 'saturn'];
        const nextIndex = (shapes.indexOf(currentShape) + 1) % shapes.length;
        calculateTargets(shapes[nextIndex]);
    }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        time += 0.005;

        const positions = points.geometry.attributes.position.array;
        const colors = points.geometry.attributes.color.array;

        // Interaction Factors
        let explosionFactor = 0;
        let colorShift = 0;
        
        if (handInteraction.active) {
            // Map pinch distance (0 to 1) to explosion
            // If pinch is tight (close to 0), system is stable. If open (1), it expands.
            // Let's invert: Pinching expands/explodes the particles
            if(handInteraction.pinchDistance < 0.1) {
                explosionFactor = 5; // Explode on pinch
            } else {
                explosionFactor = 0;
            }

            // Map x position to rotation speed
            points.rotation.y = (handInteraction.x - 0.5) * 2;
            points.rotation.x = (handInteraction.y - 0.5) * 2;
            
            colorShift = handInteraction.x;
        } else {
            points.rotation.y += 0.002;
        }

        // Update Particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const data = particlesData[i];
            const px = i * 3;
            const py = i * 3 + 1;
            const pz = i * 3 + 2;

            // Current Position
            const current = new THREE.Vector3(positions[px], positions[py], positions[pz]);
            
            // Lerp towards target shape
            current.lerp(data.target, 0.03);

            // Add Noise / Float
            const noise = Math.sin(time + i) * 0.05;
            current.x += noise;
            current.y += noise;

            // Explosion logic based on Hand
            if (explosionFactor > 0) {
                const dir = current.clone().normalize();
                current.add(dir.multiplyScalar(explosionFactor * Math.random()));
            }

            // Update Arrays
            positions[px] = current.x;
            positions[py] = current.y;
            positions[pz] = current.z;

            // Dynamic Color
            // Base color on position + time + hand interaction
            const color = new THREE.Color();
            const hue = (current.x * 0.05 + time * 0.2 + colorShift) % 1;
            const saturation = 0.8;
            const lightness = 0.5 + (explosionFactor * 0.1);
            color.setHSL(hue, saturation, lightness);

            colors[px] = color.r;
            colors[py] = color.g;
            colors[pz] = color.b;
        }

        points.geometry.attributes.position.needsUpdate = true;
        points.geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- MEDIAPIPE HAND TRACKING ---
    const videoElement = document.getElementById('video-input');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handInteraction.active = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. Get Hand Centroid (approximate by wrist or index)
            // Landmarks: 0=Wrist, 8=IndexTip, 4=ThumbTip
            const x = landmarks[9].x; // Middle finger knuckle
            const y = landmarks[9].y;

            handInteraction.x = 1 - x; // Mirror effect
            handInteraction.y = 1 - y;

            // 2. Pinch Detection (Distance between Index Tip and Thumb Tip)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );
            
            handInteraction.pinchDistance = distance;

        } else {
            handInteraction.active = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    // Start everything
    cameraUtils.start()
        .then(() => initThree())
        .catch(e => {
            console.error(e);
            document.getElementById('loading').innerText = "Error: Camera access denied or not found.";
        });

</script>
</body>
</html>
